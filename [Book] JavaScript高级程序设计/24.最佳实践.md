
# 24.最佳实践

> 可维护的代码
> 保证代码性能
> 部署代码

## 24.1 可维护性
编写可维护的代码很重要，大部分开发人员都要花费大量事件维护他人代码
确保代码可维护性，以便开发人员在此基础上更好地开始工作

### 24.1.1 什么是可维护性代码
可维护代码的特征遵循以下特点:
- 可理解性，其他人可以接手代码并理解意图，无需原开发人员完整解释
- 直观性，代码东西一看就明白，不管操作多么复杂
- 可适应性，代码以一种数据上的变化不要求完全重写的方法撰写
- 可扩展性，在代码架构上已考虑到在未来允许对核心功能进行扩展 
- 可调试性，当有地方出错，代码有足够信息确定问题所在

### 24.1.2 代码约定
一种代码变得可维护的简单途径是形成一套JS代码的书写规范

**1.可读性**
- 缩进方式 所有人采用一样的缩进方式，整个项目代码更加易于阅读
- 代码注释 每个方法注释是个可行的实践，一般有以下地方需要注释

- 函数和方法 每个函数或方法都该包含一个注释，描述目的和用于完成任务可能使用的算法，事先陈述假设，如参数代表什么是否有返回值
- 大段代码 用于完成单个任务的多行代码应该在前面放一个描述任务的注释
- 复杂的代码 如果使用一项独特的方式解决问题，需要注释中解释如何做到的
- Hack 浏览器差异，JS代码会包含一些hack，不要假设别人在看代码时候能够理解hack应对的浏览器

**2.变量和函数命名**
- 变量名应该为名词，如car或person
- 函数名应该以动词开始，如getName
- 变量和函数都应使用合乎逻辑的名字，不用担心长度

**3.变量类型透明**
变量是松散类型，容易忘记变量类型，合适的命名方式可以缓解这个问题，有三种表示变量数据的方式
1.初始化 通过初始化赋给变量一个值，暗示其将来该如何应用
``` js
var found = false;
var count = -1;
var name = "";
var person = null;
``` 
2.使用匈牙利标记法命名变量类型
``` js
var bFound;  // 布尔类型
var iCount;  // 整型
var sName;   // 字符串
var oPerson; // 对象
```
3.使用类型注释
``` js
var found /*:Boolean*/ = false;
var count /*:int*/     = 10;
var name  /*:string*/  = "Nicholas";
var person/*:Object*/  = null;
```

### 24.1.3 松散耦合
**1.解耦HTML/JavaScript**
一般来说，应该避免在JS中创建大量HTML，保持层次关系分离，可以容易确定错误来源
HTML呈现应该尽可能与JS保持分离，JS插入数据时，尽量不要插入标记

**2.解耦CSS/JavaScript**
- 通过设置className而非设置style的各种属性来实现解耦

**3.解耦应用逻辑/事件处理程序**
逻辑与事件分离，事件处理程序提取事件对象相关信息，交与处理应用逻辑的某个方法中
- 逻辑的分离使得逻辑处理更容易复用
- 可以在不附加事件情况下测试代码，容易完成单元测试/自动化应用测试

应用于业务逻辑松散耦合的几条原则
- 不要将event对象传递给其他方法，只传来自event对象中所需的数据
- 任何可以在应用层的动作都可以在不执行任何事件处理程序的情况下进行
- 任何时间处理程序都应该处理事件，然后处理转交给应用逻辑

### 24.1.4 编程实践
**1.尊重对象所有权**
尊重对象所有权，意味着不能修改不属于自己的对象：
- 不要为实例或原型添加属性
- 不要为实例或原型添加方法
- 不要重定义已存在的方法

可以通过以下方式为对象创建新的功能：
- 创建包含所需功能的新对象，并用它与相关对象进行交互
- 创建自定义类型，继承需要进行修改的类型，然后可以为自定义类型添加额外功能

**2.避免全局量**
使用命名空间将功能进行组合

**3.避免与null进行比较**
与null进行比较很少有适合的情况，按照所期望的对值进行检查而非不期望的那些
如果看到了与null比较的代码，尝试使用以下技术
- 如果值应为一个引用类型，使用instanceof操作符检查其构造函数
- 如果值应为一个基本类型，使用typeof检查其构造函数
- 如果希望对象包含某个特定的方法名，使用typeof检查其类型

**4.使用常量**
尽管JS常量没有正式提出，但是还是很有用的
这种数据从应用逻辑分离出来的思想，可以在不冒引入错误风险的同事，就改变数据
关键在于将数据和使用它的逻辑进行分离
- 重复值 任何在多处用到的值都改取一个常量，这就限制了一个值变了另一个没变的时候造成的错误
- 用户界面字符串 任何用于显示给用户的字符串，都应该抽取出来方便国际化
- URLs Web应用中，资源位置容易变更，推荐一个公共地方放所有URL
- 任意可能会改的值 如果用到字面量的时候，都问一下这个值在未来是不是会变化

## 24.2 性能
**1.避免全局查找**
可能优化脚本性能最重要的就是全局查找，使用全局查找肯定比局部查找开销更大，因为涉及作用域链上的查找
- 在一个函数中多次用到全局对象存储为局部变量总是没错

**2.避免with语句**
在性能重要的地方避免使用with，with会扩展自己的作用域

### 24.2.2 选择正确的方法
**1.避免不必要的属性查找**
常量或访问数组是一个O(1)操作，访问对象属性是一个O(n)操作
对象上任何查找都比变量或者数组消耗更长时间，所以在第一次访问到后记录下来，后面就是O(1)过程

**2.优化循环**
1）减值迭代 大多数循环从0开始，增加到某个特定值得迭代器，很多情况下，从最大值开始，在循环中不断减值的迭代器更高效
2）简化终止条件 由于每次循环过程都会计算终止条件，所以必须保证它尽可能快，避免属性查找或其他O(n)操作
3）简化循环体 循环体是执行最多的，所以要确保被最大限度地优化
4）使用后测试循环 最常用for循环和while循环都是前测试循环，do-while循环是后测试循环，可以避免最初终止条件的计算

**3.消除循环**
如果循环次数是确定的，消除循环并使用多次调用往往更快，如下代码，展开更快
``` js
process(values[0]);
process(values[1]);
process(values[2]);
```

**4.避免双重解析**
当eval、Function、setTimeout传入字符串参数的时候会发生这种情况
``` js
// 某些代码求值——避免
eval("alert('hello world!')");
// 创建新函数——避免
var sayHi = new Function("alert('Hello world')");
// 设置超时——避免
setTimeout("alert('Hello world!')", 500);
```

**5.性能的其他注意事项**
- 原生方法比较快，使用原生方法而非JS重写一个，因为原生方法使用C/C++编译出来的，比JS快很多
- switch语句比if-else快
- 位运算符快

### 24.2.3 最小语句数
**1.多个变量声明**
``` js
var count = 5,
    color = "blue",
    values = [1, 2, 3],
    now = new Date();
```

**2.插入迭代值**
``` js
var name = values[i++];
```

**3.使用数组和对象字面量**
``` js
var values = [123, 456, 789];
var person = {
  name: "Nicholas",
  age: 29
}
```

### 24.2.4 优化DOM交互
DOM操作与交互需要消耗大量事件，因为他们往往需要重新渲染整个页面或者某一部分
**1.最小化现场更新**
tips: 插入一组item，而非一个一个item插入

**2.使用innerHTML**
对于小的DOM，createElement、appendChild和innerHTML效率差不多，
对于大的DOM，createElement、appendChild比innerHTML效率慢得多，
更新时，一次插入所有innerHTML，不要使用innerHTML += ''

**3.使用事件代理**
任何冒泡事件不仅可以在事件本身上处理，还可以在任何祖父节点处理，可能的话，将事件处理挂在文档级别

**4.注意HTMLCollection**
以下情况下会返回HTMLCollection对象：
- 进行了对getElementsByTagName的调用
- 获取元素的childNodes属性
- 获取元素的attributes属性
- 访问了特殊的集合，如document.forms、document.images

在文档上任何一次查询花费都十分昂贵，减少访问HTMLCollection的次数可以极大改进脚本性能
``` js
var images = document.getElementsByTagName("img"),
    i,
    len;
// Tip1: 使用len保存images.length属性
for (i = 0, len = images.length; i < len; i++) {
  // Tip2: 使用image保存images[i]对象
  var image = images[i];
}
```

## 23.4 部署

### 23.4.1 构建过程
代码不应该原封不动放入浏览器，理由如下：
- 知识产权问题：带完整注释的代码放到线上，别人更容易知道你的意图，对它再利用，可能找到安全漏洞
- 文件大小：书写代码保证容易阅读，才能更好维护，但对于性能是不利的，浏览器并不能从额外的空白字符或者冗长的函数名得到任何好处
- 代码组织：组织代码要考虑可维护并不一定是传给浏览器的最好方式

构建代码时，将JS放入多个文件，确保每个文件有最少的代码，这样在不引入错误的情况下容易修改
代码分离成多个文件只是为了提高可维护性，并非为了部署，要进行部署，需把文件合并为一个或几个归并文件

### 23.3.2 验证
JSLint帮助查找JS代码中的语法错误以及常见的编码错误

### 23.3.3 压缩
压缩相关的两个概念:
- 代码长度：浏览器需要解析的字节数
- 配重：实际从服务器传送到浏览器的字节数

**1.文件压缩**
JS并非编译为字节码传送，代码文件通常包含浏览器执行所不需要的额外信息和格式
我们可以使用压缩工具减少文件的大小：
- 删除额外的空白（包含换行）
- 删除所有注释
- 缩短变量名

**2.HTTP压缩**
配重指实际从服务器传送到浏览器的字节数，因为现在服务器和浏览器都有压缩功能，这个字节数不一定和代码长度一样
对于Apache Web服务器有两个模块可以压缩：
- mod_gzip
- mod_deflate

## 24.4 小结
随着JS开发成熟，也出现很多最佳实践，过去一度认为只是一种爱好的东西变成了正当职业，
同时还需要经历其他编程语言一样做一些研究，如可维护性、性能和部署
JS可维护性涉及下面的代码约定：
- 来自其他语言的代码约定可以用于决定何时进行注释，如何进行缩进，不过JS需要针对其松散类型性质创造一些特殊的约定
- 由于JS必须与HTML、CSS共存，所以让各自完全定义其自己的目的非常重要，JS定义行为、HTML定义内容、CSS定义外观
- 这些职责的混淆会导致难以调试的错误和维护上的问题

随着Web应用中的JS数量增加，性能变得更加重要，因此，牢记以下事项
- JS执行所花费的事件直接影响到整个Web页面的性能，所以其重要性不能忽略
- 针对基于C语言的很多性能建议也适用于JS，有关循环性能和使用switch语句代替if语句
- 还有一个重要事情，即DOM交互开销很大，所以需要限制DOM操作次数

流程最后一步是部署，本章讨论了一些关键点
- 为了协助部署，推荐设置一个JS合并为较少文件的构建过程
- 有了构建过程也可以对源码自动运行额外的处理和过滤，例如在JS验证器来确保没有语法错误或是代码没有潜在问题
- 在部署前推荐使用压缩器将文件尽可能变小
- 和HTTP压缩一起使用可以让JS文件尽可能小，因此对整个页面性能影响会最小